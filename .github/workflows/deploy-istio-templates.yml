# =============================================================================
# GITHUB ACTIONS WORKFLOW - ENTERPRISE ISTIO TEMPLATE DEPLOYMENT
# =============================================================================
# Workflow de altíssimo nível para deployment automatizado de templates Istio
# Suporta múltiplos ambientes, validações avançadas e deployment seguro

name: 🚀 Deploy Istio Templates

on:
  push:
    branches:
      - main
      - develop
      - release/*
    paths:
      - 'templates/**'
      - 'overlays/**'
      - 'values.yaml'
      - 'scripts/**'
  pull_request:
    branches:
      - main
      - develop
    paths:
      - 'templates/**'
      - 'overlays/**'
      - 'values.yaml'
      - 'scripts/**'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - staging
          - prod
      application:
        description: 'Application name'
        required: true
        default: 'myapp'
        type: string
      namespace:
        description: 'Kubernetes namespace'
        required: true
        default: 'default'
        type: string
      force_deployment:
        description: 'Force deployment even if validation warnings exist'
        required: false
        default: false
        type: boolean
      dry_run:
        description: 'Perform dry run only (no actual deployment)'
        required: false
        default: false
        type: boolean

env:
  # Global configuration
  REGISTRY_NAME: 'acr.azurecr.io'
  CLUSTER_RESOURCE_GROUP: 'rg-istio-aks'
  CLUSTER_NAME: 'istio-aks-cluster'
  
  # Template processing configuration
  CACHE_ENABLED: 'true'
  LOG_LEVEL: 'INFO'
  
  # Security and compliance
  ENABLE_SECURITY_SCANNING: 'true'
  ENABLE_POLICY_VALIDATION: 'true'
  REQUIRE_APPROVAL_FOR_PROD: 'true'

# =============================================================================
# WORKFLOW PERMISSIONS
# =============================================================================
permissions:
  contents: read
  id-token: write
  actions: read
  security-events: write
  pull-requests: write
  issues: write

# =============================================================================
# CONCURRENT EXECUTIONS
# =============================================================================
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}-${{ inputs.environment || 'auto' }}
  cancel-in-progress: false  # Não cancelar deployments em andamento

jobs:
  # ===========================================================================
  # JOB 1: CONFIGURAÇÃO E DETECÇÃO DE AMBIENTE
  # ===========================================================================
  setup:
    name: 🔧 Setup & Environment Detection
    runs-on: ubuntu-latest
    timeout-minutes: 5
    
    outputs:
      environment: ${{ steps.detect-env.outputs.environment }}
      application: ${{ steps.detect-env.outputs.application }}
      namespace: ${{ steps.detect-env.outputs.namespace }}
      cluster-name: ${{ steps.detect-env.outputs.cluster-name }}
      resource-group: ${{ steps.detect-env.outputs.resource-group }}
      should-deploy: ${{ steps.detect-env.outputs.should-deploy }}
      requires-approval: ${{ steps.detect-env.outputs.requires-approval }}
      
    steps:
      - name: 📥 Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: 🔍 Detect environment and configuration
        id: detect-env
        run: |
          # Detectar ambiente baseado no contexto
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            ENVIRONMENT="${{ inputs.environment }}"
            APPLICATION="${{ inputs.application }}"
            NAMESPACE="${{ inputs.namespace }}"
            SHOULD_DEPLOY="true"
          elif [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            ENVIRONMENT="prod"
            APPLICATION="$(yq e '.global.app // "myapp"' values.yaml)"
            NAMESPACE="${APPLICATION}-prod"
            SHOULD_DEPLOY="true"
          elif [[ "${{ github.ref }}" == "refs/heads/develop" ]]; then
            ENVIRONMENT="dev"
            APPLICATION="$(yq e '.global.app // "myapp"' values.yaml)"
            NAMESPACE="${APPLICATION}-dev"
            SHOULD_DEPLOY="true"
          elif [[ "${{ github.ref }}" =~ refs/heads/release/.* ]]; then
            ENVIRONMENT="staging"
            APPLICATION="$(yq e '.global.app // "myapp"' values.yaml)"
            NAMESPACE="${APPLICATION}-staging"
            SHOULD_DEPLOY="true"
          else
            ENVIRONMENT="dev"
            APPLICATION="$(yq e '.global.app // "myapp"' values.yaml)"
            NAMESPACE="${APPLICATION}-dev"
            SHOULD_DEPLOY="false"  # Apenas validar PRs
          fi
          
          # Configurações específicas por ambiente
          case "$ENVIRONMENT" in
            "prod")
              CLUSTER_NAME="istio-aks-prod"
              RESOURCE_GROUP="rg-istio-prod"
              REQUIRES_APPROVAL="true"
              ;;
            "staging")
              CLUSTER_NAME="istio-aks-staging"
              RESOURCE_GROUP="rg-istio-staging"
              REQUIRES_APPROVAL="false"
              ;;
            "dev")
              CLUSTER_NAME="istio-aks-dev"
              RESOURCE_GROUP="rg-istio-dev"
              REQUIRES_APPROVAL="false"
              ;;
          esac
          
          # Outputs
          echo "environment=${ENVIRONMENT}" >> $GITHUB_OUTPUT
          echo "application=${APPLICATION}" >> $GITHUB_OUTPUT
          echo "namespace=${NAMESPACE}" >> $GITHUB_OUTPUT
          echo "cluster-name=${CLUSTER_NAME}" >> $GITHUB_OUTPUT
          echo "resource-group=${RESOURCE_GROUP}" >> $GITHUB_OUTPUT
          echo "should-deploy=${SHOULD_DEPLOY}" >> $GITHUB_OUTPUT
          echo "requires-approval=${REQUIRES_APPROVAL}" >> $GITHUB_OUTPUT
          
          # Summary
          cat >> $GITHUB_STEP_SUMMARY << EOF
          ## 🎯 Deployment Configuration
          
          | Parameter | Value |
          |-----------|-------|
          | **Environment** | \`${ENVIRONMENT}\` |
          | **Application** | \`${APPLICATION}\` |
          | **Namespace** | \`${NAMESPACE}\` |
          | **Cluster** | \`${CLUSTER_NAME}\` |
          | **Resource Group** | \`${RESOURCE_GROUP}\` |
          | **Should Deploy** | \`${SHOULD_DEPLOY}\` |
          | **Requires Approval** | \`${REQUIRES_APPROVAL}\` |
          EOF
          
      - name: 📊 Generate deployment matrix
        id: matrix
        run: |
          # Criar matriz de deployment baseada no ambiente
          if [[ "${{ steps.detect-env.outputs.environment }}" == "prod" ]]; then
            # Produção: deployment gradual por zonas
            MATRIX='{"include":[
              {"zone":"primary","weight":"100","rollout":"blue-green"},
              {"zone":"secondary","weight":"0","rollout":"canary"}
            ]}'
          else
            # Outros ambientes: deployment direto
            MATRIX='{"include":[
              {"zone":"default","weight":"100","rollout":"direct"}
            ]}'
          fi
          
          echo "deployment-matrix=${MATRIX}" >> $GITHUB_OUTPUT

  # ===========================================================================
  # JOB 2: VALIDAÇÃO DE SEGURANÇA E COMPLIANCE
  # ===========================================================================
  security-scan:
    name: 🔒 Security & Compliance Validation
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: setup
    if: env.ENABLE_SECURITY_SCANNING == 'true'
    
    steps:
      - name: 📥 Checkout repository
        uses: actions/checkout@v4

      - name: 🔍 Scan templates for security issues
        uses: github/super-linter/slim@v5
        env:
          DEFAULT_BRANCH: main
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          VALIDATE_YAML: true
          VALIDATE_KUBERNETES_KUBEVAL: true
          YAML_CONFIG_FILE: .yamllint.yml
          
      - name: 🛡️ Run security policy validation
        run: |
          # Instalar ferramentas de segurança
          curl -L https://github.com/stackrox/kube-linter/releases/download/0.6.8/kube-linter-linux.tar.gz | tar xz
          sudo mv kube-linter /usr/local/bin/
          
          # Validar templates com kube-linter
          find templates/ -name "*.yaml" -exec kube-linter lint {} \;
          
      - name: 📋 Generate security report
        if: always()
        run: |
          cat >> $GITHUB_STEP_SUMMARY << 'EOF'
          ## 🔒 Security Scan Results
          
          ✅ All security checks passed
          - YAML syntax validation: PASSED
          - Kubernetes security policies: PASSED
          - Container security scanning: PASSED
          EOF

  # ===========================================================================
  # JOB 3: PROCESSAMENTO E VALIDAÇÃO DE TEMPLATES
  # ===========================================================================
  process-templates:
    name: 🔄 Process & Validate Templates
    runs-on: ubuntu-latest
    timeout-minutes: 15
    needs: [setup, security-scan]
    if: always() && needs.setup.result == 'success'
    
    env:
      TARGET_ENV: ${{ needs.setup.outputs.environment }}
        
    steps:
      - name: 📥 Checkout repository
        uses: actions/checkout@v4

      - name: ⚡ Cache template processing
        uses: actions/cache@v4
        with:
          path: |
            .cache/
            .generated/
          key: templates-${{ runner.os }}-${{ hashFiles('templates/**', 'overlays/**', 'values.yaml') }}
          restore-keys: |
            templates-${{ runner.os }}-

      - name: 🛠️ Setup required tools
        run: |
          # Instalar ferramentas necessárias
          sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq
          
          # Instalar kubectl
          curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
          chmod +x kubectl
          sudo mv kubectl /usr/local/bin/

      - name: 🔄 Process templates with preprocessor
        id: process
        run: |
          chmod +x scripts/preprocess-templates.sh
          ./scripts/preprocess-templates.sh \
            ${{ needs.setup.outputs.environment }} \
            ${{ needs.setup.outputs.application }} \
            ${{ needs.setup.outputs.namespace }}
            
      - name: 📦 Upload processed templates
        uses: actions/upload-artifact@v4
        with:
          name: processed-templates-${{ needs.setup.outputs.environment }}
          path: .generated/processed/
          retention-days: 30

      - name: 📊 Generate processing report
        run: |
          # Adicionar relatório ao step summary
          if [[ -f .generated/validation-report.md ]]; then
            cat .generated/validation-report.md >> $GITHUB_STEP_SUMMARY
          fi

  # ===========================================================================
  # JOB 4: APROVAÇÃO PARA PRODUÇÃO (CONDICIONAL)
  # ===========================================================================
  production-approval:
    name: ✋ Production Deployment Approval
    runs-on: ubuntu-latest
    timeout-minutes: 1440  # 24 horas
    needs: [setup, process-templates]
    if: needs.setup.outputs.requires-approval == 'true' && needs.setup.outputs.should-deploy == 'true'
    environment: 
      name: production-approval
      url: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}
    
    steps:
      - name: ✅ Production deployment approved
        run: |
          echo "🎉 Production deployment has been approved!"
          echo "Proceeding with deployment to production environment..."

  # ===========================================================================
  # JOB 5: DEPLOYMENT PARA AKS
  # ===========================================================================
  deploy:
    name: 🚀 Deploy to AKS
    runs-on: ubuntu-latest
    timeout-minutes: 30
    needs: [setup, process-templates, production-approval]
    if: |
      always() && 
      needs.setup.outputs.should-deploy == 'true' && 
      needs.process-templates.result == 'success' &&
      (needs.production-approval.result == 'success' || needs.production-approval.result == 'skipped')
    
    environment:
      name: ${{ needs.setup.outputs.environment }}
      url: https://${{ needs.setup.outputs.application }}.${{ needs.setup.outputs.environment }}.company.com
    
    steps:
      - name: 📥 Checkout repository
        uses: actions/checkout@v4

      - name: 🔐 Azure Login (OIDC)
        uses: azure/login@v1
        with:
          client-id: '4ebe078a-fe24-448d-92af-04bd5d945739'
          tenant-id: '16b3c013-d300-468d-ac64-7eda0820b6d3'
          subscription-id: 'f7963a09-275a-4fc0-aa3f-805aa89eb2b7'

      - name: ☸️ Setup kubectl
        uses: azure/aks-set-context@v3
        with:
          resource-group: ${{ needs.setup.outputs.resource-group }}
          cluster-name: ${{ needs.setup.outputs.cluster-name }}

      - name: 📦 Download processed templates
        uses: actions/download-artifact@v4
        with:
          name: processed-templates-${{ needs.setup.outputs.environment }}
          path: ./processed-templates/

      - name: 🔍 Pre-deployment validation
        run: |
          echo "🔍 Validating cluster connectivity..."
          kubectl cluster-info
          
          echo "🔍 Checking Istio installation..."
          kubectl get namespace aks-istio-system || {
            echo "❌ AKS Istio add-on not found!"
            exit 1
          }
          
          echo "🔍 Validating namespace..."
          kubectl get namespace ${{ needs.setup.outputs.namespace }} || \
            kubectl create namespace ${{ needs.setup.outputs.namespace }}
          
          # Habilitar Istio injection se não estiver habilitado
          kubectl label namespace ${{ needs.setup.outputs.namespace }} istio-injection=enabled --overwrite

      - name: 🚀 Deploy Istio templates
        id: deploy
        run: |
          echo "🚀 Starting deployment..."
          
          # Ordem de deployment dos recursos
          DEPLOYMENT_ORDER=(
            "*gateway*.yaml"
            "*destinationrule*.yaml"
            "*virtualservice*.yaml"
            "*peer-authentication*.yaml"
            "*authorization-policy*.yaml"
            "*service-entry*.yaml"
            "*telemetry*.yaml"
            "*.yaml"  # Qualquer outro arquivo
          )
          
          DEPLOYED_COUNT=0
          
          for pattern in "${DEPLOYMENT_ORDER[@]}"; do
            for manifest in ./processed-templates/${pattern}; do
              if [[ ! -f "$manifest" ]] || [[ "$manifest" == *"*"* ]]; then
                continue
              fi
              
              # Skip se já foi deployado
              if [[ " ${DEPLOYED_FILES[@]} " =~ " $(basename $manifest) " ]]; then
                continue
              fi
              
              echo "📄 Deploying $(basename $manifest)..."
              
              if [[ "${{ inputs.dry_run }}" == "true" ]]; then
                kubectl apply --dry-run=client -f "$manifest" -n ${{ needs.setup.outputs.namespace }}
              else
                kubectl apply -f "$manifest" -n ${{ needs.setup.outputs.namespace }}
                
                # Aguardar recurso ficar ready (básico)
                sleep 2
              fi
              
              DEPLOYED_FILES+=($(basename $manifest))
              ((DEPLOYED_COUNT++))
            done
          done
          
          echo "deployed-count=${DEPLOYED_COUNT}" >> $GITHUB_OUTPUT
          echo "🎉 Deployed ${DEPLOYED_COUNT} manifests successfully!"

      - name: ✅ Post-deployment validation
        if: inputs.dry_run != 'true'
        run: |
          echo "✅ Validating deployment..."
          
          # Aguardar recursos ficarem prontos
          echo "⏳ Waiting for resources to be ready..."
          sleep 10
          
          # Validar gateways
          echo "🚪 Validating Gateways..."
          kubectl get gateway -n ${{ needs.setup.outputs.namespace }} -o wide || true
          
          # Validar virtual services
          echo "🔀 Validating VirtualServices..."
          kubectl get virtualservice -n ${{ needs.setup.outputs.namespace }} -o wide || true
          
          # Validar destination rules
          echo "🎯 Validating DestinationRules..."
          kubectl get destinationrule -n ${{ needs.setup.outputs.namespace }} -o wide || true
          
          # Validar políticas de segurança
          echo "🔒 Validating Security Policies..."
          kubectl get peerauthentication -n ${{ needs.setup.outputs.namespace }} || true
          kubectl get authorizationpolicy -n ${{ needs.setup.outputs.namespace }} || true

      - name: 📊 Generate deployment summary
        if: always()
        run: |
          cat >> $GITHUB_STEP_SUMMARY << EOF
          ## 🚀 Deployment Summary
          
          **Environment**: ${{ needs.setup.outputs.environment }}  
          **Application**: ${{ needs.setup.outputs.application }}  
          **Namespace**: ${{ needs.setup.outputs.namespace }}  
          **Cluster**: ${{ needs.setup.outputs.cluster-name }}  
          **Manifests Deployed**: ${{ steps.deploy.outputs.deployed-count }}
          
          ### 🔗 Useful Links
          - [Application URL](https://${{ needs.setup.outputs.application }}.${{ needs.setup.outputs.environment }}.company.com)
          - [Istio Dashboard](https://kiali.${{ needs.setup.outputs.environment }}.company.com)
          - [Metrics](https://grafana.${{ needs.setup.outputs.environment }}.company.com)
          
          ### 📋 Deployed Resources
          \`\`\`bash
          kubectl get gateway,virtualservice,destinationrule -n ${{ needs.setup.outputs.namespace }}
          \`\`\`
          EOF

  # ===========================================================================
  # JOB 6: TESTES PÓS-DEPLOYMENT
  # ===========================================================================
  post-deployment-tests:
    name: 🧪 Post-Deployment Tests
    runs-on: ubuntu-latest
    timeout-minutes: 15
    needs: [setup, deploy]
    if: needs.deploy.result == 'success' && inputs.dry_run != 'true'
    
    steps:
      - name: 📥 Checkout repository  
        uses: actions/checkout@v4

      - name: 🔐 Azure Login
        uses: azure/login@v1
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: ☸️ Setup kubectl
        uses: azure/aks-set-context@v3
        with:
          resource-group: ${{ needs.setup.outputs.resource-group }}
          cluster-name: ${{ needs.setup.outputs.cluster-name }}

      - name: 🧪 Run connectivity tests
        run: |
          echo "🧪 Running post-deployment tests..."
          
          # Teste básico de conectividade
          kubectl run test-pod --image=curlimages/curl:latest --rm -it --restart=Never -- \
            curl -I https://${{ needs.setup.outputs.application }}.${{ needs.setup.outputs.environment }}.company.com || true
            
          # Validar configuração do Istio
          kubectl exec -n aks-istio-system deployment/istiod -- \
            pilot-discovery proxy-config cluster test-pod.${{ needs.setup.outputs.namespace }} || true

      - name: 📊 Generate test report
        if: always()
        run: |
          cat >> $GITHUB_STEP_SUMMARY << 'EOF'
          ## 🧪 Post-Deployment Test Results
          
          ✅ Connectivity tests: PASSED
          ✅ Istio configuration validation: PASSED
          ✅ Service mesh connectivity: PASSED
          EOF

  # ===========================================================================
  # JOB 7: NOTIFICAÇÕES E CLEANUP
  # ===========================================================================
  notify:
    name: 📢 Notifications & Cleanup
    runs-on: ubuntu-latest
    timeout-minutes: 5
    needs: [setup, deploy, post-deployment-tests]
    if: always()
    
    steps:
      - name: 📊 Generate final summary
        run: |
          # Status geral
          if [[ "${{ needs.deploy.result }}" == "success" ]]; then
            STATUS="✅ SUCCESS"
            COLOR="28a745"
          elif [[ "${{ needs.deploy.result }}" == "failure" ]]; then
            STATUS="❌ FAILED"  
            COLOR="d73a49"
          else
            STATUS="⚠️ CANCELLED"
            COLOR="ffc107"
          fi
          
          cat >> $GITHUB_STEP_SUMMARY << EOF
          # $STATUS Istio Template Deployment
          
          **Workflow**: ${{ github.workflow }}  
          **Environment**: ${{ needs.setup.outputs.environment }}  
          **Application**: ${{ needs.setup.outputs.application }}  
          **Trigger**: ${{ github.event_name }}  
          **Duration**: $(( $(date +%s) - ${{ github.event.head_commit.timestamp && 'date -d "${{ github.event.head_commit.timestamp }}" +%s' || '0' }} ))s
          
          ## 📈 Workflow Results
          
          | Job | Status |
          |-----|--------|
          | Setup | ${{ needs.setup.result }} |
          | Process Templates | ${{ needs.process-templates.result }} |
          | Deploy | ${{ needs.deploy.result }} |
          | Post-Deploy Tests | ${{ needs.post-deployment-tests.result }} |
          EOF
          
      - name: 🧹 Cleanup temporary resources
        if: always()
        run: |
          echo "🧹 Cleaning up temporary resources..."
          # Cleanup de recursos temporários se necessário