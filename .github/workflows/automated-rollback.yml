name: üîÑ Automated Rollback System

on:
  workflow_dispatch:
    inputs:
      service:
        description: 'Service to monitor'
        required: true
        default: 'order-service'
        type: choice
        options:
        - order-service
        - payment-service
        - user-service
        - notification-service
      monitoring_duration:
        description: 'Monitoring duration in minutes'
        required: false
        default: '10'
      success_rate_threshold:
        description: 'Success rate threshold (0.0-1.0)'
        required: false
        default: '0.95'
      latency_p95_threshold:
        description: 'P95 latency threshold in ms'
        required: false
        default: '1000'
      error_rate_threshold:
        description: 'Error rate threshold (0.0-1.0)'
        required: false
        default: '0.05'
      cpu_threshold:
        description: 'CPU usage threshold (0.0-1.0)'
        required: false
        default: '0.80'
      memory_threshold:
        description: 'Memory usage threshold (0.0-1.0)'
        required: false
        default: '0.85'
  schedule:
    # Run every 5 minutes during business hours
    - cron: '*/5 9-17 * * 1-5'

env:
  NAMESPACE: ecommerce-demo
  CLUSTER_NAME: aks-labs
  RESOURCE_GROUP: rg-aks-labs

permissions:
  id-token: write
  contents: read

jobs:
  continuous-monitoring:
    runs-on: ubuntu-latest
    environment: production
    
    steps:
    - name: üîÑ Checkout Repository
      uses: actions/checkout@v4
      
    - name: üîê Azure Login via OIDC
      uses: azure/login@v1
      with:
        client-id: ${{ secrets.AZURE_CLIENT_ID }}
        tenant-id: ${{ secrets.AZURE_TENANT_ID }}
        subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
        
    - name: ‚öôÔ∏è Setup kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'latest'
        
    - name: üîó Get AKS Credentials
      run: |
        az aks get-credentials \
          --resource-group ${{ env.RESOURCE_GROUP }} \
          --name ${{ env.CLUSTER_NAME }} \
          --overwrite-existing
          
    - name: üìä Collect Current Metrics
      id: metrics
      run: |
        SERVICE="${{ github.event.inputs.service || 'order-service' }}"
        
        echo "üìä Collecting metrics for $SERVICE..."
        
        # Get pod metrics (CPU, Memory)
        POD_METRICS=$(kubectl top pods -n ${{ env.NAMESPACE }} -l app=$SERVICE --no-headers 2>/dev/null || echo "")
        
        if [ -n "$POD_METRICS" ]; then
          CPU_USAGE=$(echo "$POD_METRICS" | awk '{sum+=$2} END {print sum/NR}' | sed 's/m//')
          MEMORY_USAGE=$(echo "$POD_METRICS" | awk '{sum+=$3} END {print sum/NR}' | sed 's/Mi//')
          
          # Convert to percentages (assuming 500m CPU limit and 256Mi memory limit)
          CPU_PERCENT=$(echo "scale=3; $CPU_USAGE / 500" | bc -l)
          MEMORY_PERCENT=$(echo "scale=3; $MEMORY_USAGE / 256" | bc -l)
        else
          CPU_PERCENT="0.0"
          MEMORY_PERCENT="0.0"
        fi
        
        # Simulate application metrics (in real scenario, query Prometheus)
        SUCCESS_RATE=$(echo "scale=3; 0.950 + ($RANDOM % 50) / 1000" | bc -l)
        ERROR_RATE=$(echo "scale=3; 0.010 + ($RANDOM % 40) / 1000" | bc -l)
        LATENCY_P95=$(echo "200 + $RANDOM % 300" | bc)
        
        # Get deployment info
        CURRENT_VERSION=$(kubectl get deployment $SERVICE -n ${{ env.NAMESPACE }} -o jsonpath='{.metadata.labels.deployment-version}' 2>/dev/null || echo "unknown")
        REPLICA_COUNT=$(kubectl get deployment $SERVICE -n ${{ env.NAMESPACE }} -o jsonpath='{.status.replicas}' 2>/dev/null || echo "0")
        READY_REPLICAS=$(kubectl get deployment $SERVICE -n ${{ env.NAMESPACE }} -o jsonpath='{.status.readyReplicas}' 2>/dev/null || echo "0")
        
        echo "üìà Current Metrics for $SERVICE:"
        echo "  Version: $CURRENT_VERSION"
        echo "  Replicas: $READY_REPLICAS/$REPLICA_COUNT"
        echo "  Success Rate: $SUCCESS_RATE"
        echo "  Error Rate: $ERROR_RATE"
        echo "  Latency P95: ${LATENCY_P95}ms"
        echo "  CPU Usage: ${CPU_PERCENT} (${CPU_USAGE}m)"
        echo "  Memory Usage: ${MEMORY_PERCENT} (${MEMORY_USAGE}Mi)"
        
        # Export metrics for threshold checking
        echo "success_rate=$SUCCESS_RATE" >> $GITHUB_OUTPUT
        echo "error_rate=$ERROR_RATE" >> $GITHUB_OUTPUT
        echo "latency_p95=$LATENCY_P95" >> $GITHUB_OUTPUT
        echo "cpu_percent=$CPU_PERCENT" >> $GITHUB_OUTPUT
        echo "memory_percent=$MEMORY_PERCENT" >> $GITHUB_OUTPUT
        echo "current_version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
        echo "ready_replicas=$READY_REPLICAS" >> $GITHUB_OUTPUT
        echo "total_replicas=$REPLICA_COUNT" >> $GITHUB_OUTPUT
        
    - name: üö® Check Health Thresholds
      id: health_check
      run: |
        SUCCESS_RATE="${{ steps.metrics.outputs.success_rate }}"
        ERROR_RATE="${{ steps.metrics.outputs.error_rate }}"
        LATENCY_P95="${{ steps.metrics.outputs.latency_p95 }}"
        CPU_PERCENT="${{ steps.metrics.outputs.cpu_percent }}"
        MEMORY_PERCENT="${{ steps.metrics.outputs.memory_percent }}"
        READY_REPLICAS="${{ steps.metrics.outputs.ready_replicas }}"
        TOTAL_REPLICAS="${{ steps.metrics.outputs.total_replicas }}"
        
        # Thresholds
        SUCCESS_THRESHOLD="${{ github.event.inputs.success_rate_threshold || '0.95' }}"
        ERROR_THRESHOLD="${{ github.event.inputs.error_rate_threshold || '0.05' }}"
        LATENCY_THRESHOLD="${{ github.event.inputs.latency_p95_threshold || '1000' }}"
        CPU_THRESHOLD="${{ github.event.inputs.cpu_threshold || '0.80' }}"
        MEMORY_THRESHOLD="${{ github.event.inputs.memory_threshold || '0.85' }}"
        
        ROLLBACK_NEEDED=false
        ROLLBACK_REASONS=()
        
        echo "üîç Checking health thresholds..."
        
        # Check success rate
        if (( $(echo "$SUCCESS_RATE < $SUCCESS_THRESHOLD" | bc -l) )); then
          echo "‚ùå Success rate ($SUCCESS_RATE) below threshold ($SUCCESS_THRESHOLD)"
          ROLLBACK_NEEDED=true
          ROLLBACK_REASONS+=("success_rate")
        fi
        
        # Check error rate
        if (( $(echo "$ERROR_RATE > $ERROR_THRESHOLD" | bc -l) )); then
          echo "‚ùå Error rate ($ERROR_RATE) above threshold ($ERROR_THRESHOLD)"
          ROLLBACK_NEEDED=true
          ROLLBACK_REASONS+=("error_rate")
        fi
        
        # Check latency
        if (( $(echo "$LATENCY_P95 > $LATENCY_THRESHOLD" | bc -l) )); then
          echo "‚ùå Latency P95 (${LATENCY_P95}ms) above threshold (${LATENCY_THRESHOLD}ms)"
          ROLLBACK_NEEDED=true
          ROLLBACK_REASONS+=("latency")
        fi
        
        # Check CPU usage
        if (( $(echo "$CPU_PERCENT > $CPU_THRESHOLD" | bc -l) )); then
          echo "‚ùå CPU usage ($CPU_PERCENT) above threshold ($CPU_THRESHOLD)"
          ROLLBACK_NEEDED=true
          ROLLBACK_REASONS+=("cpu")
        fi
        
        # Check memory usage
        if (( $(echo "$MEMORY_PERCENT > $MEMORY_THRESHOLD" | bc -l) )); then
          echo "‚ùå Memory usage ($MEMORY_PERCENT) above threshold ($MEMORY_THRESHOLD)"
          ROLLBACK_NEEDED=true
          ROLLBACK_REASONS+=("memory")
        fi
        
        # Check replica availability
        if [ "$READY_REPLICAS" != "$TOTAL_REPLICAS" ] || [ "$READY_REPLICAS" = "0" ]; then
          echo "‚ùå Replica availability issue ($READY_REPLICAS/$TOTAL_REPLICAS ready)"
          ROLLBACK_NEEDED=true
          ROLLBACK_REASONS+=("availability")
        fi
        
        if [ "$ROLLBACK_NEEDED" = "true" ]; then
          REASONS_STRING=$(IFS=,; echo "${ROLLBACK_REASONS[*]}")
          echo "üö® ROLLBACK NEEDED - Reasons: $REASONS_STRING"
          echo "rollback_needed=true" >> $GITHUB_OUTPUT
          echo "rollback_reasons=$REASONS_STRING" >> $GITHUB_OUTPUT
        else
          echo "‚úÖ All health checks passed"
          echo "rollback_needed=false" >> $GITHUB_OUTPUT
        fi
        
    - name: üìã Get Rollback Target
      id: rollback_target
      if: steps.health_check.outputs.rollback_needed == 'true'
      run: |
        SERVICE="${{ github.event.inputs.service || 'order-service' }}"
        
        echo "üîç Finding rollback target for $SERVICE..."
        
        # Get deployment history
        REVISION_HISTORY=$(kubectl rollout history deployment/$SERVICE -n ${{ env.NAMESPACE }} --revision=0 2>/dev/null || echo "")
        
        if [ -n "$REVISION_HISTORY" ]; then
          # Get previous revision
          PREVIOUS_REVISION=$(kubectl rollout history deployment/$SERVICE -n ${{ env.NAMESPACE }} | tail -2 | head -1 | awk '{print $1}')
          
          if [ -n "$PREVIOUS_REVISION" ] && [ "$PREVIOUS_REVISION" != "REVISION" ]; then
            echo "üìã Previous revision found: $PREVIOUS_REVISION"
            echo "rollback_revision=$PREVIOUS_REVISION" >> $GITHUB_OUTPUT
            echo "rollback_available=true" >> $GITHUB_OUTPUT
          else
            echo "‚ö†Ô∏è No previous revision available for rollback"
            echo "rollback_available=false" >> $GITHUB_OUTPUT
          fi
        else
          echo "‚ö†Ô∏è Unable to get deployment history"
          echo "rollback_available=false" >> $GITHUB_OUTPUT
        fi
        
    - name: üîÑ Execute Automatic Rollback
      if: steps.health_check.outputs.rollback_needed == 'true' && steps.rollback_target.outputs.rollback_available == 'true'
      run: |
        SERVICE="${{ github.event.inputs.service || 'order-service' }}"
        ROLLBACK_REVISION="${{ steps.rollback_target.outputs.rollback_revision }}"
        ROLLBACK_REASONS="${{ steps.health_check.outputs.rollback_reasons }}"
        
        echo "üö® EXECUTING AUTOMATIC ROLLBACK"
        echo "Service: $SERVICE"
        echo "Target Revision: $ROLLBACK_REVISION"
        echo "Reasons: $ROLLBACK_REASONS"
        
        # Create rollback annotation for audit trail
        kubectl annotate deployment $SERVICE -n ${{ env.NAMESPACE }} \
          rollback.istio-aks-templates/timestamp="$(date -Iseconds)" \
          rollback.istio-aks-templates/reasons="$ROLLBACK_REASONS" \
          rollback.istio-aks-templates/triggered-by="automated-monitoring" \
          rollback.istio-aks-templates/previous-version="${{ steps.metrics.outputs.current_version }}" \
          --overwrite
        
        # Execute rollback
        kubectl rollout undo deployment/$SERVICE -n ${{ env.NAMESPACE }} --to-revision=$ROLLBACK_REVISION
        
        # Wait for rollback to complete
        echo "‚è≥ Waiting for rollback to complete..."
        kubectl rollout status deployment/$SERVICE -n ${{ env.NAMESPACE }} --timeout=300s
        
        # Verify rollback success
        NEW_READY_REPLICAS=$(kubectl get deployment $SERVICE -n ${{ env.NAMESPACE }} -o jsonpath='{.status.readyReplicas}')
        TOTAL_REPLICAS=$(kubectl get deployment $SERVICE -n ${{ env.NAMESPACE }} -o jsonpath='{.status.replicas}')
        
        if [ "$NEW_READY_REPLICAS" = "$TOTAL_REPLICAS" ] && [ "$NEW_READY_REPLICAS" != "0" ]; then
          echo "‚úÖ Rollback completed successfully"
          echo "üìä New status: $NEW_READY_REPLICAS/$TOTAL_REPLICAS replicas ready"
        else
          echo "‚ùå Rollback may have failed"
          echo "üìä Current status: $NEW_READY_REPLICAS/$TOTAL_REPLICAS replicas ready"
          exit 1
        fi
        
    - name: üìä Post-Rollback Verification
      if: steps.health_check.outputs.rollback_needed == 'true' && steps.rollback_target.outputs.rollback_available == 'true'
      run: |
        SERVICE="${{ github.event.inputs.service || 'order-service' }}"
        
        echo "üîç Verifying service health after rollback..."
        
        # Wait for service to stabilize
        sleep 60
        
        # Run health checks
        for i in {1..5}; do
          echo "Health check $i/5..."
          
          # Test service endpoint
          kubectl run health-check-$i --image=curlimages/curl --rm -i --restart=Never -n ${{ env.NAMESPACE }} -- \
            curl -f -s --max-time 10 http://$SERVICE.${{ env.NAMESPACE }}.svc.cluster.local:8080/ || {
            echo "‚ö†Ô∏è Health check $i failed"
          }
          
          sleep 10
        done
        
        # Get updated metrics
        POD_METRICS=$(kubectl top pods -n ${{ env.NAMESPACE }} -l app=$SERVICE --no-headers 2>/dev/null || echo "")
        
        if [ -n "$POD_METRICS" ]; then
          CPU_USAGE=$(echo "$POD_METRICS" | awk '{sum+=$2} END {print sum/NR}' | sed 's/m//')
          MEMORY_USAGE=$(echo "$POD_METRICS" | awk '{sum+=$3} END {print sum/NR}' | sed 's/Mi//')
          
          echo "üìä Post-rollback metrics:"
          echo "  CPU Usage: ${CPU_USAGE}m"
          echo "  Memory Usage: ${MEMORY_USAGE}Mi"
        fi
        
        echo "‚úÖ Post-rollback verification completed"
        
    - name: üìß Send Rollback Notification
      if: steps.health_check.outputs.rollback_needed == 'true'
      run: |
        SERVICE="${{ github.event.inputs.service || 'order-service' }}"
        ROLLBACK_REASONS="${{ steps.health_check.outputs.rollback_reasons }}"
        ROLLBACK_AVAILABLE="${{ steps.rollback_target.outputs.rollback_available }}"
        
        if [ "$ROLLBACK_AVAILABLE" = "true" ]; then
          STATUS="‚úÖ COMPLETED"
          MESSAGE="Automatic rollback executed successfully for $SERVICE"
        else
          STATUS="‚ùå FAILED"
          MESSAGE="Automatic rollback needed but no previous revision available for $SERVICE"
        fi
        
        echo "üìß Rollback Notification"
        echo "======================="
        echo "Service: $SERVICE"
        echo "Status: $STATUS"
        echo "Reasons: $ROLLBACK_REASONS"
        echo "Message: $MESSAGE"
        echo "Timestamp: $(date -Iseconds)"
        echo "Cluster: ${{ env.CLUSTER_NAME }}"
        echo "Namespace: ${{ env.NAMESPACE }}"
        
        # In a real scenario, send notification via:
        # - Slack webhook
        # - Microsoft Teams
        # - Email via SendGrid
        # - PagerDuty alert
        # - Azure Monitor alert
        
    - name: üìã Generate Rollback Report
      if: steps.health_check.outputs.rollback_needed == 'true'
      run: |
        SERVICE="${{ github.event.inputs.service || 'order-service' }}"
        ROLLBACK_REASONS="${{ steps.health_check.outputs.rollback_reasons }}"
        
        REPORT_FILE="/tmp/rollback-report-$(date +%Y%m%d-%H%M%S).md"
        
        cat > $REPORT_FILE << EOF
        # Automatic Rollback Report
        
        **Date:** $(date -Iseconds)
        **Service:** $SERVICE
        **Cluster:** ${{ env.CLUSTER_NAME }}
        **Namespace:** ${{ env.NAMESPACE }}
        
        ## Rollback Trigger
        
        **Reasons:** $ROLLBACK_REASONS
        
        ## Metrics at Rollback Time
        
        - **Success Rate:** ${{ steps.metrics.outputs.success_rate }}
        - **Error Rate:** ${{ steps.metrics.outputs.error_rate }}
        - **Latency P95:** ${{ steps.metrics.outputs.latency_p95 }}ms
        - **CPU Usage:** ${{ steps.metrics.outputs.cpu_percent }}
        - **Memory Usage:** ${{ steps.metrics.outputs.memory_percent }}
        - **Replica Status:** ${{ steps.metrics.outputs.ready_replicas }}/${{ steps.metrics.outputs.total_replicas }}
        
        ## Thresholds
        
        - **Success Rate Threshold:** ${{ github.event.inputs.success_rate_threshold || '0.95' }}
        - **Error Rate Threshold:** ${{ github.event.inputs.error_rate_threshold || '0.05' }}
        - **Latency Threshold:** ${{ github.event.inputs.latency_p95_threshold || '1000' }}ms
        - **CPU Threshold:** ${{ github.event.inputs.cpu_threshold || '0.80' }}
        - **Memory Threshold:** ${{ github.event.inputs.memory_threshold || '0.85' }}
        
        ## Actions Taken
        
        1. Health threshold violation detected
        2. Previous deployment revision identified
        3. Automatic rollback executed
        4. Post-rollback verification performed
        5. Notification sent to operations team
        
        ## Recommendations
        
        1. Investigate root cause of performance degradation
        2. Review deployment process for the failed version
        3. Update monitoring thresholds if necessary
        4. Consider implementing canary deployments for future releases
        
        ---
        *Generated by Istio AKS Templates Automated Rollback System*
        EOF
        
        echo "üìã Rollback report generated: $REPORT_FILE"
        cat $REPORT_FILE
        
        # In a real scenario, upload report to:
        # - Azure Blob Storage
        # - SharePoint
        # - Confluence
        # - Internal documentation system

  health-dashboard:
    runs-on: ubuntu-latest
    environment: production
    
    steps:
    - name: üîÑ Checkout Repository
      uses: actions/checkout@v4
      
    - name: üîê Azure Login via OIDC
      uses: azure/login@v1
      with:
        client-id: ${{ secrets.AZURE_CLIENT_ID }}
        tenant-id: ${{ secrets.AZURE_TENANT_ID }}
        subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
        
    - name: ‚öôÔ∏è Setup kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'latest'
        
    - name: üîó Get AKS Credentials
      run: |
        az aks get-credentials \
          --resource-group ${{ env.RESOURCE_GROUP }} \
          --name ${{ env.CLUSTER_NAME }} \
          --overwrite-existing
          
    - name: üìä Generate Health Dashboard
      run: |
        echo "üìä Generating health dashboard for all services..."
        
        SERVICES=("frontend" "api-gateway" "user-service" "order-service" "payment-service" "notification-service")
        
        DASHBOARD_FILE="/tmp/health-dashboard-$(date +%Y%m%d-%H%M%S).html"
        
        cat > $DASHBOARD_FILE << 'EOF'
        <!DOCTYPE html>
        <html>
        <head>
            <title>Service Health Dashboard</title>
            <style>
                body { font-family: Arial, sans-serif; margin: 20px; background: #f5f5f5; }
                .container { max-width: 1200px; margin: 0 auto; }
                .header { text-align: center; margin-bottom: 30px; }
                .services { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px; }
                .service { background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
                .service h3 { margin-top: 0; color: #333; }
                .status { padding: 5px 10px; border-radius: 4px; font-weight: bold; margin-bottom: 15px; }
                .status.healthy { background: #d4edda; color: #155724; }
                .status.warning { background: #fff3cd; color: #856404; }
                .status.critical { background: #f8d7da; color: #721c24; }
                .metrics { margin-top: 10px; }
                .metric { display: flex; justify-content: space-between; margin: 5px 0; padding: 5px; background: #f8f9fa; border-radius: 4px; }
                .timestamp { text-align: center; margin-top: 20px; color: #666; }
                .rollback-history { background: white; padding: 20px; border-radius: 8px; margin-top: 20px; }
            </style>
        </head>
        <body>
            <div class="container">
                <div class="header">
                    <h1>üè• Service Health Dashboard</h1>
                    <h2>Istio Service Mesh - AKS Cluster</h2>
                </div>
                
                <div class="services">
        EOF
        
        for service in "${SERVICES[@]}"; do
          # Get service metrics
          REPLICA_STATUS=$(kubectl get deployment $service -n ${{ env.NAMESPACE }} -o jsonpath='{.status.readyReplicas}/{.status.replicas}' 2>/dev/null || echo "0/0")
          CURRENT_VERSION=$(kubectl get deployment $service -n ${{ env.NAMESPACE }} -o jsonpath='{.metadata.labels.deployment-version}' 2>/dev/null || echo "unknown")
          
          # Simulate health status
          HEALTH_STATUS=$([ $((RANDOM % 10)) -lt 8 ] && echo "healthy" || echo "warning")
          SUCCESS_RATE=$(echo "scale=3; 0.950 + ($RANDOM % 50) / 1000" | bc -l)
          LATENCY=$(echo "150 + $RANDOM % 200" | bc)
          CPU_USAGE=$(echo "$RANDOM % 300 + 50" | bc)
          MEMORY_USAGE=$(echo "$RANDOM % 150 + 80" | bc)
          
          cat >> $DASHBOARD_FILE << EOF
                    <div class="service">
                        <h3>üîß $service</h3>
                        <div class="status $HEALTH_STATUS">$(echo $HEALTH_STATUS | tr '[:lower:]' '[:upper:]')</div>
                        <div class="metrics">
                            <div class="metric"><span>Version:</span> <span>$CURRENT_VERSION</span></div>
                            <div class="metric"><span>Replicas:</span> <span>$REPLICA_STATUS</span></div>
                            <div class="metric"><span>Success Rate:</span> <span>$SUCCESS_RATE</span></div>
                            <div class="metric"><span>Latency P95:</span> <span>${LATENCY}ms</span></div>
                            <div class="metric"><span>CPU Usage:</span> <span>${CPU_USAGE}m</span></div>
                            <div class="metric"><span>Memory Usage:</span> <span>${MEMORY_USAGE}Mi</span></div>
                        </div>
                    </div>
        EOF
        done
        
        # Get rollback history
        ROLLBACK_HISTORY=""
        for service in "${SERVICES[@]}"; do
          ROLLBACK_INFO=$(kubectl get deployment $service -n ${{ env.NAMESPACE }} -o jsonpath='{.metadata.annotations.rollback\.istio-aks-templates/timestamp}' 2>/dev/null || echo "")
          if [ -n "$ROLLBACK_INFO" ]; then
            ROLLBACK_REASONS=$(kubectl get deployment $service -n ${{ env.NAMESPACE }} -o jsonpath='{.metadata.annotations.rollback\.istio-aks-templates/reasons}' 2>/dev/null || echo "")
            ROLLBACK_HISTORY="$ROLLBACK_HISTORY<li><strong>$service</strong>: $ROLLBACK_INFO ($ROLLBACK_REASONS)</li>"
          fi
        done
        
        cat >> $DASHBOARD_FILE << EOF
                </div>
                
                <div class="rollback-history">
                    <h3>üîÑ Recent Rollback History</h3>
                    <ul>
                        $ROLLBACK_HISTORY
                        $([ -z "$ROLLBACK_HISTORY" ] && echo "<li>No recent rollbacks</li>")
                    </ul>
                </div>
                
                <div class="timestamp">
                    Last updated: $(date -Iseconds)
                </div>
            </div>
        </body>
        </html>
        EOF
        
        echo "üìä Health dashboard generated: $DASHBOARD_FILE"
        
        # Display summary
        echo ""
        echo "üìã Service Health Summary:"
        echo "========================="
        for service in "${SERVICES[@]}"; do
          REPLICA_STATUS=$(kubectl get deployment $service -n ${{ env.NAMESPACE }} -o jsonpath='{.status.readyReplicas}/{.status.replicas}' 2>/dev/null || echo "0/0")
          echo "  $service: $REPLICA_STATUS replicas"
        done
