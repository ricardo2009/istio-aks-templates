name: üöÄ Deploy E-commerce Platform

on:
  workflow_dispatch:
    inputs:
      action:
        description: 'Action to perform'
        required: true
        default: 'deploy'
        type: choice
        options:
        - deploy
        - destroy
        - status
      environment:
        description: 'Target environment'
        required: true
        default: 'demo'
        type: choice
        options:
        - demo
        - staging
        - production

env:
  NAMESPACE: ecommerce-${{ github.event.inputs.environment }}
  DOMAIN: ecommerce-${{ github.event.inputs.environment }}.aks-labs.com
  CLUSTER_NAME: aks-labs
  RESOURCE_GROUP: rg-aks-labs

permissions:
  id-token: write
  contents: read

jobs:
  deploy:
    if: github.event.inputs.action == 'deploy'
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment }}
    
    steps:
    - name: üîÑ Checkout Repository
      uses: actions/checkout@v4
      
    - name: üîê Azure Login via OIDC
      uses: azure/login@v1
      with:
        client-id: ${{ secrets.AZURE_CLIENT_ID }}
        tenant-id: ${{ secrets.AZURE_TENANT_ID }}
        subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
        
    - name: ‚öôÔ∏è Setup kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'latest'
        
    - name: üîó Get AKS Credentials
      run: |
        az aks get-credentials \
          --resource-group ${{ env.RESOURCE_GROUP }} \
          --name ${{ env.CLUSTER_NAME }} \
          --overwrite-existing
          
    - name: üîç Verify Cluster Connection
      run: |
        kubectl cluster-info
        kubectl get nodes
        
    - name: üîç Verify Istio Installation
      run: |
        kubectl get namespace aks-istio-system
        kubectl get pods -n aks-istio-system
        
    - name: üì¶ Create Namespace
      run: |
        kubectl apply -f demo-app/k8s-manifests/namespace.yaml
        kubectl get namespace ${{ env.NAMESPACE }}
        
    - name: üõ°Ô∏è Apply Security Policies
      run: |
        echo "Applying namespace-level security policies..."
        
        chmod +x scripts/render.sh
        
        ./scripts/render.sh \
          -f templates/security/namespace-security-policy.yaml \
          -s ecommerce -n ${{ env.NAMESPACE }}
          
        kubectl apply -f manifests/ecommerce/namespace-security-policy.yaml
        
        echo "‚úÖ Security policies applied"
        
    - name: üöÄ Deploy Application Services
      run: |
        echo "Deploying e-commerce application services..."
        
        kubectl apply -f demo-app/k8s-manifests/frontend.yaml
        kubectl apply -f demo-app/k8s-manifests/api-gateway.yaml
        kubectl apply -f demo-app/k8s-manifests/backend-services.yaml
        
        echo "‚úÖ Application services deployed"
        
    - name: ‚è≥ Wait for Pods to be Ready
      run: |
        echo "Waiting for all pods to be ready..."
        
        services=("frontend" "api-gateway" "user-service" "order-service" "payment-service" "notification-service")
        
        for service in "${services[@]}"; do
          echo "Waiting for $service..."
          kubectl wait --for=condition=ready pod \
            --selector=app=$service \
            --namespace=${{ env.NAMESPACE }} \
            --timeout=300s
          echo "‚úÖ $service is ready"
        done
        
    - name: üåê Configure Istio Gateway
      run: |
        echo "Configuring Istio Gateway..."
        
        ./scripts/render.sh \
          -f templates/base/advanced-gateway.yaml \
          -s frontend -n ${{ env.NAMESPACE }} \
          -h ${{ env.DOMAIN }} \
          --tls-secret ecommerce-tls
          
        kubectl apply -f manifests/frontend/advanced-gateway.yaml
        
        echo "‚úÖ Istio Gateway configured"
        
    - name: üîÄ Configure Traffic Management
      run: |
        echo "Configuring traffic management for all services..."
        
        services=("frontend" "api-gateway" "user-service" "order-service" "payment-service" "notification-service")
        
        for service in "${services[@]}"; do
          echo "Configuring traffic management for $service..."
          
          # VirtualService
          ./scripts/render.sh \
            -f templates/traffic-management/advanced-virtual-service.yaml \
            -s "$service" -n ${{ env.NAMESPACE }} \
            -h ${{ env.DOMAIN }}
            
          kubectl apply -f "manifests/$service/advanced-virtual-service.yaml"
          
          # DestinationRule with circuit breakers
          if [ "$service" = "payment-service" ]; then
            ./scripts/render.sh \
              -f templates/traffic-management/advanced-destination-rule.yaml \
              -s "$service" -n ${{ env.NAMESPACE }} \
              --max-connections 30 \
              --consecutive-5xx-errors 3 \
              --base-ejection-time 60s
          else
            ./scripts/render.sh \
              -f templates/traffic-management/advanced-destination-rule.yaml \
              -s "$service" -n ${{ env.NAMESPACE }}
          fi
          
          kubectl apply -f "manifests/$service/advanced-destination-rule.yaml"
          
          echo "‚úÖ Traffic management configured for $service"
        done
        
    - name: üîí Apply Security Configurations
      run: |
        echo "Applying security configurations for all services..."
        
        services=("frontend" "api-gateway" "user-service" "order-service" "payment-service" "notification-service")
        
        for service in "${services[@]}"; do
          echo "Applying security for $service..."
          
          # PeerAuthentication (mTLS STRICT)
          ./scripts/render.sh \
            -f templates/security/peer-authentication.yaml \
            -s "$service" -n ${{ env.NAMESPACE }}
            
          kubectl apply -f "manifests/$service/peer-authentication.yaml"
          
          # AuthorizationPolicy
          ./scripts/render.sh \
            -f templates/security/authorization-policy.yaml \
            -s "$service" -n ${{ env.NAMESPACE }} \
            --caller-sa api-gateway \
            --method GET \
            --path "/"
            
          kubectl apply -f "manifests/$service/authorization-policy.yaml"
          
          echo "‚úÖ Security configured for $service"
        done
        
    - name: üìä Configure Observability
      run: |
        echo "Configuring observability for all services..."
        
        services=("frontend" "api-gateway" "user-service" "order-service" "payment-service" "notification-service")
        
        for service in "${services[@]}"; do
          echo "Configuring observability for $service..."
          
          ./scripts/render.sh \
            -f templates/observability/advanced-telemetry.yaml \
            -s "$service" -n ${{ env.NAMESPACE }}
            
          kubectl apply -f "manifests/$service/advanced-telemetry.yaml"
          
          echo "‚úÖ Observability configured for $service"
        done
        
    - name: üîç Verify Deployment
      run: |
        echo "Verifying deployment status..."
        
        echo "üì¶ Pods:"
        kubectl get pods -n ${{ env.NAMESPACE }}
        
        echo ""
        echo "üåê Services:"
        kubectl get services -n ${{ env.NAMESPACE }}
        
        echo ""
        echo "üîß Istio Configurations:"
        kubectl get gateway,virtualservice,destinationrule -n ${{ env.NAMESPACE }}
        
        echo ""
        echo "üîí Security Policies:"
        kubectl get peerauthentication,authorizationpolicy -n ${{ env.NAMESPACE }}
        
        echo ""
        echo "üìä Telemetry:"
        kubectl get telemetry -n ${{ env.NAMESPACE }}
        
    - name: üåê Get Application URL
      run: |
        echo "Getting application access information..."
        
        EXTERNAL_IP=$(kubectl get service aks-istio-ingressgateway-external \
          -n aks-istio-system \
          -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "")
          
        if [ -n "$EXTERNAL_IP" ]; then
          echo "üåê Application URL: https://$EXTERNAL_IP"
          echo "üåê Domain: ${{ env.DOMAIN }}"
          echo "üìù Add this to your /etc/hosts file:"
          echo "$EXTERNAL_IP ${{ env.DOMAIN }}"
        else
          echo "‚ö†Ô∏è External IP not yet assigned. Check again in a few minutes:"
          echo "kubectl get service aks-istio-ingressgateway-external -n aks-istio-system"
        fi
        
    - name: üìã Deployment Summary
      run: |
        echo "üéâ E-commerce Platform Deployment Summary"
        echo "========================================"
        echo "‚úÖ Namespace: ${{ env.NAMESPACE }}"
        echo "‚úÖ Services deployed: 6"
        echo "‚úÖ Istio Gateway configured"
        echo "‚úÖ mTLS STRICT enabled"
        echo "‚úÖ Circuit breakers configured"
        echo "‚úÖ Observability enabled"
        echo "‚úÖ Security policies applied"
        echo ""
        echo "üéØ Next Steps:"
        echo "1. Access the application via the external IP"
        echo "2. Run advanced deployment strategies"
        echo "3. Monitor metrics and test rollback scenarios"
        echo "4. Execute chaos engineering tests"

  destroy:
    if: github.event.inputs.action == 'destroy'
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment }}
    
    steps:
    - name: üîÑ Checkout Repository
      uses: actions/checkout@v4
      
    - name: üîê Azure Login via OIDC
      uses: azure/login@v1
      with:
        client-id: ${{ secrets.AZURE_CLIENT_ID }}
        tenant-id: ${{ secrets.AZURE_TENANT_ID }}
        subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
        
    - name: ‚öôÔ∏è Setup kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'latest'
        
    - name: üîó Get AKS Credentials
      run: |
        az aks get-credentials \
          --resource-group ${{ env.RESOURCE_GROUP }} \
          --name ${{ env.CLUSTER_NAME }} \
          --overwrite-existing
          
    - name: üóëÔ∏è Remove Istio Configurations
      run: |
        echo "Removing Istio configurations..."
        
        kubectl delete gateway,virtualservice,destinationrule,peerauthentication,authorizationpolicy,telemetry \
          --all -n ${{ env.NAMESPACE }} --ignore-not-found=true
          
        echo "‚úÖ Istio configurations removed"
        
    - name: üóëÔ∏è Remove Application
      run: |
        echo "Removing application resources..."
        
        kubectl delete -f demo-app/k8s-manifests/ --ignore-not-found=true
        
        echo "‚úÖ Application resources removed"
        
    - name: üóëÔ∏è Remove Namespace
      run: |
        echo "Removing namespace..."
        
        kubectl delete namespace ${{ env.NAMESPACE }} --ignore-not-found=true
        
        echo "‚úÖ Namespace removed"
        
    - name: üìã Cleanup Summary
      run: |
        echo "üßπ Cleanup Summary"
        echo "=================="
        echo "‚úÖ Istio configurations removed"
        echo "‚úÖ Application services removed"
        echo "‚úÖ Namespace removed"
        echo "‚úÖ Environment cleaned up"

  status:
    if: github.event.inputs.action == 'status'
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment }}
    
    steps:
    - name: üîÑ Checkout Repository
      uses: actions/checkout@v4
      
    - name: üîê Azure Login via OIDC
      uses: azure/login@v1
      with:
        client-id: ${{ secrets.AZURE_CLIENT_ID }}
        tenant-id: ${{ secrets.AZURE_TENANT_ID }}
        subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
        
    - name: ‚öôÔ∏è Setup kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'latest'
        
    - name: üîó Get AKS Credentials
      run: |
        az aks get-credentials \
          --resource-group ${{ env.RESOURCE_GROUP }} \
          --name ${{ env.CLUSTER_NAME }} \
          --overwrite-existing
          
    - name: üîç Check Environment Status
      run: |
        echo "üîç Checking environment status for ${{ env.NAMESPACE }}..."
        
        if kubectl get namespace ${{ env.NAMESPACE }} >/dev/null 2>&1; then
          echo "‚úÖ Namespace ${{ env.NAMESPACE }} exists"
          
          echo ""
          echo "üì¶ Pods Status:"
          kubectl get pods -n ${{ env.NAMESPACE }}
          
          echo ""
          echo "üåê Services Status:"
          kubectl get services -n ${{ env.NAMESPACE }}
          
          echo ""
          echo "üîß Istio Configurations:"
          kubectl get gateway,virtualservice,destinationrule -n ${{ env.NAMESPACE }}
          
          echo ""
          echo "üîí Security Policies:"
          kubectl get peerauthentication,authorizationpolicy -n ${{ env.NAMESPACE }}
          
          echo ""
          echo "üìä Resource Usage:"
          kubectl top pods -n ${{ env.NAMESPACE }} 2>/dev/null || echo "Metrics not available"
          
        else
          echo "‚ùå Namespace ${{ env.NAMESPACE }} does not exist"
          echo "Run the deploy action first to create the environment"
        fi
