# =============================================================================
# GITHUB ACTIONS WORKFLOW - ENTERPRISE ISTIO TEMPLATE MAINTENANCE & MONITORING
# =============================================================================
# Workflow de altíssimo nível para manutenção automatizada, monitoramento
# de saúde dos deployments e operações de limpeza

name: 🔧 Maintenance & Monitoring

on:
  schedule:
    # Execução diária às 01:00 UTC para verificações de saúde
    - cron: '0 1 * * *'
    # Execução semanal aos domingos às 03:00 UTC para manutenção completa
    - cron: '0 3 * * 0'
  workflow_dispatch:
    inputs:
      operation:
        description: 'Maintenance operation to perform'
        required: true
        default: 'health-check'
        type: choice
        options:
          - health-check
          - full-maintenance
          - cleanup-old-resources
          - update-dependencies
          - security-scan
          - performance-audit
      environment:
        description: 'Target environment (or all)'
        required: false
        default: 'all'
        type: choice
        options:
          - all
          - dev
          - staging
          - prod
      dry_run:
        description: 'Perform dry run (no actual changes)'
        required: false
        default: true
        type: boolean

env:
  # Maintenance configuration
  MAX_AGE_DAYS: '30'
  CLEANUP_THRESHOLD: '85'
  ALERT_WEBHOOK: ${{ secrets.TEAMS_WEBHOOK_URL }}
  
  # Monitoring thresholds
  CPU_THRESHOLD: '80'
  MEMORY_THRESHOLD: '80'
  ERROR_RATE_THRESHOLD: '5'
  
  # Security scan settings
  VULNERABILITY_SEVERITY: 'HIGH,CRITICAL'
  COMPLIANCE_LEVEL: 'CIS'

permissions:
  contents: write
  security-events: write
  actions: write
  pull-requests: write
  issues: write

# =============================================================================
# CONCURRENT EXECUTIONS - Allow only one maintenance at a time
# =============================================================================
concurrency:
  group: maintenance-${{ github.workflow }}
  cancel-in-progress: false

jobs:
  # ===========================================================================
  # JOB 1: VERIFICAÇÃO DE SAÚDE DOS CLUSTERS
  # ===========================================================================
  health-check:
    name: 🏥 Cluster Health Check
    runs-on: ubuntu-latest
    timeout-minutes: 20
    if: inputs.operation == 'health-check' || inputs.operation == 'full-maintenance' || github.event_name == 'schedule'
    
    strategy:
      matrix:
        environment: [dev, staging, prod]
      fail-fast: false
      
    outputs:
      health-status: ${{ steps.health.outputs.status }}
      issues-found: ${{ steps.health.outputs.issues }}
      
    steps:
      - name: 📥 Checkout repository
        uses: actions/checkout@v4

      - name: ⚙️ Setup tools
        run: |
          # Instalar ferramentas necessárias
          sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq
          
          # Instalar kubectl
          curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
          chmod +x kubectl && sudo mv kubectl /usr/local/bin/
          
          # Instalar istioctl
          curl -L https://istio.io/downloadIstio | ISTIO_VERSION=1.20.0 sh -
          sudo mv istio-1.20.0/bin/istioctl /usr/local/bin/

      - name: 🔐 Azure Login
        if: inputs.environment == 'all' || inputs.environment == matrix.environment
        uses: azure/login@v1
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: ☸️ Setup kubectl context
        if: inputs.environment == 'all' || inputs.environment == matrix.environment
        uses: azure/aks-set-context@v3
        with:
          resource-group: rg-istio-${{ matrix.environment }}
          cluster-name: istio-aks-${{ matrix.environment }}

      - name: 🏥 Perform comprehensive health check
        id: health
        if: inputs.environment == 'all' || inputs.environment == matrix.environment
        run: |
          echo "🏥 Starting health check for ${{ matrix.environment }} environment..."
          
          ISSUES=()
          STATUS="HEALTHY"
          
          # 1. Verificar conectividade do cluster
          echo "🔍 Checking cluster connectivity..."
          if ! kubectl cluster-info >/dev/null 2>&1; then
            ISSUES+=("❌ Cluster connectivity failed")
            STATUS="UNHEALTHY"
          else
            echo "✅ Cluster connectivity: OK"
          fi
          
          # 2. Verificar saúde do Istio
          echo "🔍 Checking Istio health..."
          if ! kubectl get namespace aks-istio-system >/dev/null 2>&1; then
            ISSUES+=("❌ Istio system namespace not found")
            STATUS="UNHEALTHY"
          else
            # Verificar pods do sistema Istio
            ISTIO_PODS=$(kubectl get pods -n aks-istio-system --no-headers | wc -l)
            READY_PODS=$(kubectl get pods -n aks-istio-system --field-selector=status.phase=Running --no-headers | wc -l)
            
            if [[ $READY_PODS -lt $ISTIO_PODS ]]; then
              ISSUES+=("⚠️ Some Istio system pods are not ready ($READY_PODS/$ISTIO_PODS)")
              STATUS="DEGRADED"
            else
              echo "✅ Istio system pods: $READY_PODS/$ISTIO_PODS ready"
            fi
          fi
          
          # 3. Verificar recursos de aplicação
          echo "🔍 Checking application resources..."
          APP_NAMESPACES=$(kubectl get namespaces -l istio-injection=enabled --no-headers -o custom-columns=":metadata.name" | grep -v istio)
          
          for ns in $APP_NAMESPACES; do
            echo "📋 Checking namespace: $ns"
            
            # Verificar gateways
            GATEWAYS=$(kubectl get gateway -n $ns --no-headers 2>/dev/null | wc -l)
            if [[ $GATEWAYS -eq 0 ]]; then
              ISSUES+=("⚠️ No gateways found in namespace $ns")
            fi
            
            # Verificar virtual services
            VIRTUAL_SERVICES=$(kubectl get virtualservice -n $ns --no-headers 2>/dev/null | wc -l)
            if [[ $VIRTUAL_SERVICES -eq 0 ]]; then
              ISSUES+=("⚠️ No virtual services found in namespace $ns")
            fi
            
            # Verificar pods da aplicação
            TOTAL_PODS=$(kubectl get pods -n $ns --no-headers 2>/dev/null | wc -l)
            RUNNING_PODS=$(kubectl get pods -n $ns --field-selector=status.phase=Running --no-headers 2>/dev/null | wc -l)
            
            if [[ $RUNNING_PODS -lt $TOTAL_PODS ]]; then
              ISSUES+=("⚠️ Some application pods not ready in $ns ($RUNNING_PODS/$TOTAL_PODS)")
              STATUS="DEGRADED"
            fi
          done
          
          # 4. Verificar configuração Istio
          echo "🔍 Running Istio configuration analysis..."
          ISTIO_ISSUES=$(istioctl analyze --all-namespaces 2>&1 | grep -E "(Error|Warning)" | wc -l)
          if [[ $ISTIO_ISSUES -gt 0 ]]; then
            ISSUES+=("⚠️ $ISTIO_ISSUES Istio configuration issues found")
            STATUS="DEGRADED"
          fi
          
          # 5. Verificar métricas de performance
          echo "🔍 Checking performance metrics..."
          # Verificar uso de CPU dos nodes
          CPU_USAGE=$(kubectl top nodes 2>/dev/null | awk 'NR>1 {gsub(/%/, "", $3); if ($3 > '${{ env.CPU_THRESHOLD }}') print $1 " " $3}' | wc -l)
          if [[ $CPU_USAGE -gt 0 ]]; then
            ISSUES+=("⚠️ $CPU_USAGE nodes with high CPU usage (>${{ env.CPU_THRESHOLD }}%)")
            STATUS="DEGRADED"
          fi
          
          # Resumir resultados
          echo "status=${STATUS}" >> $GITHUB_OUTPUT
          echo "issues=${#ISSUES[@]}" >> $GITHUB_OUTPUT
          
          # Criar relatório
          cat > health-report-${{ matrix.environment }}.md << EOF
          # 🏥 Health Check Report - ${{ matrix.environment }} Environment
          
          **Status**: ${STATUS}  
          **Timestamp**: $(date -u '+%Y-%m-%d %H:%M:%S UTC')  
          **Issues Found**: ${#ISSUES[@]}
          
          ## 📊 Health Summary
          
          | Component | Status |
          |-----------|--------|
          | Cluster Connectivity | ✅ OK |
          | Istio System | $([ "$STATUS" != "UNHEALTHY" ] && echo "✅ OK" || echo "❌ FAILED") |
          | Application Resources | $([ ${#ISSUES[@]} -eq 0 ] && echo "✅ OK" || echo "⚠️ ISSUES") |
          | Configuration | $([ $ISTIO_ISSUES -eq 0 ] && echo "✅ OK" || echo "⚠️ WARNINGS") |
          | Performance | $([ $CPU_USAGE -eq 0 ] && echo "✅ OK" || echo "⚠️ HIGH USAGE") |
          
          ## 📋 Issues Detected
          
          $(if [[ ${#ISSUES[@]} -eq 0 ]]; then
            echo "🎉 No issues detected - system is healthy!"
          else
            printf '%s\n' "${ISSUES[@]}"
          fi)
          
          ## 🔧 Recommended Actions
          
          $(if [[ "$STATUS" == "UNHEALTHY" ]]; then
            echo "- 🚨 Immediate investigation required"
            echo "- 📞 Contact operations team"
          elif [[ "$STATUS" == "DEGRADED" ]]; then
            echo "- 🔍 Review identified issues"
            echo "- 📊 Monitor performance metrics"
          else
            echo "- ✅ System is healthy - continue monitoring"
          fi)
          EOF
          
          echo "✅ Health check completed for ${{ matrix.environment }}"

      - name: 📤 Upload health report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: health-report-${{ matrix.environment }}
          path: health-report-${{ matrix.environment }}.md
          retention-days: 30

  # ===========================================================================
  # JOB 2: LIMPEZA DE RECURSOS ANTIGOS
  # ===========================================================================
  cleanup-resources:
    name: 🧹 Cleanup Old Resources
    runs-on: ubuntu-latest
    timeout-minutes: 15
    needs: health-check
    if: inputs.operation == 'cleanup-old-resources' || inputs.operation == 'full-maintenance'
    
    strategy:
      matrix:
        environment: [dev, staging]  # Não incluir prod automaticamente
      fail-fast: false
      
    steps:
      - name: 📥 Checkout repository
        uses: actions/checkout@v4

      - name: 🔐 Azure Login
        uses: azure/login@v1
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: ☸️ Setup kubectl
        uses: azure/aks-set-context@v3
        with:
          resource-group: rg-istio-${{ matrix.environment }}
          cluster-name: istio-aks-${{ matrix.environment }}

      - name: 🧹 Clean old resources
        run: |
          echo "🧹 Starting cleanup for ${{ matrix.environment }} environment..."
          
          CLEANUP_ACTIONS=()
          
          # 1. Limpar failed jobs
          echo "🔍 Looking for failed jobs..."
          FAILED_JOBS=$(kubectl get jobs --all-namespaces --field-selector=status.successful=0 --no-headers | wc -l)
          if [[ $FAILED_JOBS -gt 0 ]]; then
            if [[ "${{ inputs.dry_run }}" == "false" ]]; then
              kubectl delete jobs --all-namespaces --field-selector=status.successful=0
              CLEANUP_ACTIONS+=("Deleted $FAILED_JOBS failed jobs")
            else
              CLEANUP_ACTIONS+=("[DRY RUN] Would delete $FAILED_JOBS failed jobs")
            fi
          fi
          
          # 2. Limpar pods em estado evicted
          echo "🔍 Looking for evicted pods..."
          EVICTED_PODS=$(kubectl get pods --all-namespaces --field-selector=status.phase=Failed -o json | \
            jq -r '.items[] | select(.status.reason=="Evicted") | "\(.metadata.namespace) \(.metadata.name)"' | wc -l)
          if [[ $EVICTED_PODS -gt 0 ]]; then
            if [[ "${{ inputs.dry_run }}" == "false" ]]; then
              kubectl get pods --all-namespaces --field-selector=status.phase=Failed -o json | \
                jq -r '.items[] | select(.status.reason=="Evicted") | "\(.metadata.namespace) \(.metadata.name)"' | \
                while read ns name; do kubectl delete pod $name -n $ns; done
              CLEANUP_ACTIONS+=("Deleted $EVICTED_PODS evicted pods")
            else
              CLEANUP_ACTIONS+=("[DRY RUN] Would delete $EVICTED_PODS evicted pods")
            fi
          fi
          
          # 3. Limpar configmaps antigos (exceto system)
          echo "🔍 Looking for old configmaps..."
          OLD_CONFIGMAPS=$(kubectl get configmaps --all-namespaces -o json | \
            jq -r --arg date "$(date -d '${{ env.MAX_AGE_DAYS }} days ago' -u '+%Y-%m-%dT%H:%M:%SZ')" \
            '.items[] | select(.metadata.creationTimestamp < $date and (.metadata.namespace | startswith("istio") | not) and (.metadata.namespace != "kube-system")) | "\(.metadata.namespace) \(.metadata.name)"' | wc -l)
          if [[ $OLD_CONFIGMAPS -gt 0 ]]; then
            CLEANUP_ACTIONS+=("[INFO] Found $OLD_CONFIGMAPS old configmaps (manual review recommended)")
          fi
          
          # 4. Verificar uso de storage
          echo "🔍 Checking storage usage..."
          # Esta seria uma verificação mais específica dependendo do ambiente
          
          # Gerar relatório de limpeza
          cat > cleanup-report-${{ matrix.environment }}.md << EOF
          # 🧹 Cleanup Report - ${{ matrix.environment }} Environment
          
          **Timestamp**: $(date -u '+%Y-%m-%d %H:%M:%S UTC')  
          **Mode**: ${{ inputs.dry_run == 'true' && 'DRY RUN' || 'EXECUTION' }}
          
          ## 📊 Cleanup Summary
          
          $(if [[ ${#CLEANUP_ACTIONS[@]} -eq 0 ]]; then
            echo "🎉 No cleanup needed - environment is clean!"
          else
            printf '- %s\n' "${CLEANUP_ACTIONS[@]}"
          fi)
          
          ## 📈 Resource Statistics
          
          - **Failed Jobs Found**: $FAILED_JOBS
          - **Evicted Pods Found**: $EVICTED_PODS
          - **Old ConfigMaps**: $OLD_CONFIGMAPS
          
          EOF
          
          echo "✅ Cleanup completed for ${{ matrix.environment }}"

      - name: 📤 Upload cleanup report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: cleanup-report-${{ matrix.environment }}
          path: cleanup-report-${{ matrix.environment }}.md
          retention-days: 30

  # ===========================================================================
  # JOB 3: AUDITORIA DE SEGURANÇA
  # ===========================================================================
  security-audit:
    name: 🔒 Security Audit
    runs-on: ubuntu-latest
    timeout-minutes: 25
    if: inputs.operation == 'security-scan' || inputs.operation == 'full-maintenance' || github.event.schedule == '0 3 * * 0'
    
    steps:
      - name: 📥 Checkout repository
        uses: actions/checkout@v4

      - name: 🛡️ Security scan - Templates
        run: |
          echo "🛡️ Running security audit on templates..."
          
          # Instalar ferramentas de segurança
          curl -L https://github.com/stackrox/kube-linter/releases/download/0.6.8/kube-linter-linux.tar.gz | tar xz
          sudo mv kube-linter /usr/local/bin/
          
          # Scan templates
          SECURITY_ISSUES=0
          
          echo "🔍 Scanning templates with kube-linter..."
          if ! kube-linter lint templates/ > security-scan-results.txt 2>&1; then
            SECURITY_ISSUES=$(grep -c "Error\|Warning" security-scan-results.txt || echo 0)
          fi
          
          echo "security-issues=${SECURITY_ISSUES}" >> $GITHUB_ENV

      - name: 🔍 RBAC and Security Policies Audit
        run: |
          echo "🔍 Auditing RBAC and security policies..."
          
          # Verificar se existem políticas de segurança nos templates
          PEER_AUTH_COUNT=$(find templates/ -name "*.yaml" -exec grep -l "kind: PeerAuthentication" {} \; | wc -l)
          AUTHZ_POLICY_COUNT=$(find templates/ -name "*.yaml" -exec grep -l "kind: AuthorizationPolicy" {} \; | wc -l)
          
          cat > security-audit-report.md << EOF
          # 🔒 Security Audit Report
          
          **Timestamp**: $(date -u '+%Y-%m-%d %H:%M:%S UTC')
          
          ## 📊 Security Posture Summary
          
          | Category | Count | Status |
          |----------|--------|--------|
          | Security Issues Found | $SECURITY_ISSUES | $([ $SECURITY_ISSUES -eq 0 ] && echo "✅ CLEAN" || echo "⚠️ NEEDS ATTENTION") |
          | PeerAuthentication Policies | $PEER_AUTH_COUNT | $([ $PEER_AUTH_COUNT -gt 0 ] && echo "✅ IMPLEMENTED" || echo "⚠️ MISSING") |
          | Authorization Policies | $AUTHZ_POLICY_COUNT | $([ $AUTHZ_POLICY_COUNT -gt 0 ] && echo "✅ IMPLEMENTED" || echo "⚠️ MISSING") |
          
          ## 🛡️ Security Recommendations
          
          $(if [[ $SECURITY_ISSUES -eq 0 ]]; then
            echo "✅ No security issues detected in templates"
          else
            echo "⚠️ $SECURITY_ISSUES security issues found - review required"
            echo ""
            echo "### Issues Found:"
            echo "\`\`\`"
            head -20 security-scan-results.txt || echo "See security-scan-results.txt for details"
            echo "\`\`\`"
          fi)
          
          $(if [[ $PEER_AUTH_COUNT -eq 0 ]]; then
            echo "- 🔧 Consider implementing PeerAuthentication policies for mTLS"
          fi)
          
          $(if [[ $AUTHZ_POLICY_COUNT -eq 0 ]]; then
            echo "- 🔧 Consider implementing AuthorizationPolicy for access control"
          fi)
          
          ## 📋 Security Checklist
          
          - [x] Template security scanning completed
          - [$([ $SECURITY_ISSUES -eq 0 ] && echo "x" || echo " ")] No high/critical security issues
          - [$([ $PEER_AUTH_COUNT -gt 0 ] && echo "x" || echo " ")] mTLS policies implemented  
          - [$([ $AUTHZ_POLICY_COUNT -gt 0 ] && echo "x" || echo " ")] Authorization policies implemented
          EOF

      - name: 📤 Upload security audit results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: security-audit-report
          path: |
            security-audit-report.md
            security-scan-results.txt
          retention-days: 90

  # ===========================================================================
  # JOB 4: ATUALIZAÇÃO DE DEPENDÊNCIAS
  # ===========================================================================
  update-dependencies:
    name: 🔄 Update Dependencies
    runs-on: ubuntu-latest
    timeout-minutes: 15
    if: inputs.operation == 'update-dependencies' || inputs.operation == 'full-maintenance'
    
    steps:
      - name: 📥 Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: 🔍 Check for Istio updates
        id: istio-check
        run: |
          echo "🔍 Checking for Istio updates..."
          
          # Current version nos templates
          CURRENT_VERSION=$(grep -r "istio.io/" templates/ | head -1 | grep -oP 'v\d+\.\d+\.\d+' || echo "unknown")
          
          # Latest version from GitHub API
          LATEST_VERSION=$(curl -s https://api.github.com/repos/istio/istio/releases/latest | jq -r .tag_name)
          
          echo "current-version=${CURRENT_VERSION}" >> $GITHUB_OUTPUT
          echo "latest-version=${LATEST_VERSION}" >> $GITHUB_OUTPUT
          
          if [[ "$CURRENT_VERSION" != "$LATEST_VERSION" ]]; then
            echo "update-available=true" >> $GITHUB_OUTPUT
            echo "🔄 Update available: $CURRENT_VERSION → $LATEST_VERSION"
          else
            echo "update-available=false" >> $GITHUB_OUTPUT
            echo "✅ Istio version is up to date"
          fi

      - name: 📦 Update tool versions in workflows
        if: steps.istio-check.outputs.update-available == 'true' && inputs.dry_run == 'false'
        run: |
          echo "📦 Updating tool versions..."
          
          # Update Istio version in workflows
          find .github/workflows/ -name "*.yml" -exec sed -i "s/ISTIO_VERSION: '[^']*'/ISTIO_VERSION: '${{ steps.istio-check.outputs.latest-version }}'/g" {} \;
          
          # Update Istio version in scripts
          find scripts/ -name "*.sh" -exec sed -i "s/ISTIO_VERSION=[^[:space:]]*/ISTIO_VERSION=${{ steps.istio-check.outputs.latest-version }}/g" {} \;

      - name: 🔄 Update documentation
        run: |
          echo "🔄 Updating documentation..."
          
          # Update README with latest versions
          if [[ -f README.md ]]; then
            sed -i "s/Istio [0-9]\+\.[0-9]\+\.[0-9]\+/Istio ${{ steps.istio-check.outputs.latest-version }}/g" README.md || true
          fi

      - name: 📊 Generate update report
        run: |
          cat > dependency-update-report.md << EOF
          # 🔄 Dependency Update Report
          
          **Timestamp**: $(date -u '+%Y-%m-%d %H:%M:%S UTC')  
          **Mode**: ${{ inputs.dry_run == 'true' && 'DRY RUN' || 'EXECUTION' }}
          
          ## 📦 Version Updates
          
          | Component | Current | Latest | Action |
          |-----------|---------|---------|--------|
          | Istio | ${{ steps.istio-check.outputs.current-version }} | ${{ steps.istio-check.outputs.latest-version }} | $([ "${{ steps.istio-check.outputs.update-available }}" == "true" ] && echo "🔄 UPDATE" || echo "✅ UP TO DATE") |
          
          ## 📋 Files Updated
          
          $(if [[ "${{ steps.istio-check.outputs.update-available }}" == "true" && "${{ inputs.dry_run }}" == "false" ]]; then
            echo "- Workflow files (.github/workflows/)"
            echo "- Script files (scripts/)"
            echo "- Documentation (README.md)"
          elif [[ "${{ inputs.dry_run }}" == "true" ]]; then
            echo "[DRY RUN] Would update workflow files, scripts, and documentation"
          else
            echo "No updates needed"
          fi)
          EOF

      - name: 🚀 Create Pull Request for updates
        if: steps.istio-check.outputs.update-available == 'true' && inputs.dry_run == 'false'
        uses: peter-evans/create-pull-request@v5
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          commit-message: "🔄 Auto-update: Istio ${{ steps.istio-check.outputs.latest-version }} and dependencies"
          title: "🔄 Dependency Update: Istio ${{ steps.istio-check.outputs.latest-version }}"
          body: |
            ## 🔄 Automated Dependency Update
            
            This PR updates the following dependencies:
            
            - **Istio**: ${{ steps.istio-check.outputs.current-version }} → ${{ steps.istio-check.outputs.latest-version }}
            
            ### Changes Made
            - Updated Istio version in GitHub Actions workflows
            - Updated version references in scripts
            - Updated documentation
            
            ### Testing Required
            - [ ] Run validation workflow
            - [ ] Test template processing
            - [ ] Verify Istio compatibility
            
            ---
            *This PR was created automatically by the maintenance workflow*
          branch: auto-update/istio-${{ steps.istio-check.outputs.latest-version }}
          labels: |
            maintenance
            dependencies
            auto-update

      - name: 📤 Upload update report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: dependency-update-report
          path: dependency-update-report.md
          retention-days: 30

  # ===========================================================================
  # JOB 5: CONSOLIDAÇÃO E NOTIFICAÇÕES
  # ===========================================================================
  consolidate-reports:
    name: 📊 Consolidate Reports & Notify
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: [health-check, cleanup-resources, security-audit, update-dependencies]
    if: always()
    
    steps:
      - name: 📥 Download all reports
        uses: actions/download-artifact@v4
        with:
          path: ./reports/

      - name: 📊 Generate consolidated maintenance report
        run: |
          echo "📊 Generating consolidated report..."
          
          # Calculate overall health status
          OVERALL_STATUS="HEALTHY"
          TOTAL_ISSUES=0
          
          # Process health reports
          if [[ -d reports/health-report-dev ]]; then
            DEV_ISSUES=$(grep "Issues Found:" reports/health-report-dev/*.md | grep -oP '\d+' | head -1 || echo "0")
            TOTAL_ISSUES=$((TOTAL_ISSUES + DEV_ISSUES))
          fi
          
          if [[ -d reports/health-report-staging ]]; then
            STAGING_ISSUES=$(grep "Issues Found:" reports/health-report-staging/*.md | grep -oP '\d+' | head -1 || echo "0")
            TOTAL_ISSUES=$((TOTAL_ISSUES + STAGING_ISSUES))
          fi
          
          if [[ -d reports/health-report-prod ]]; then
            PROD_ISSUES=$(grep "Issues Found:" reports/health-report-prod/*.md | grep -oP '\d+' | head -1 || echo "0")
            TOTAL_ISSUES=$((TOTAL_ISSUES + PROD_ISSUES))
          fi
          
          if [[ $TOTAL_ISSUES -gt 0 ]]; then
            OVERALL_STATUS="NEEDS ATTENTION"
          fi
          
          # Create consolidated report
          cat > maintenance-summary.md << EOF
          # 🔧 Consolidated Maintenance Report
          
          **Date**: $(date -u '+%Y-%m-%d %H:%M:%S UTC')  
          **Operation**: ${{ inputs.operation || 'scheduled' }}  
          **Overall Status**: $OVERALL_STATUS  
          **Total Issues**: $TOTAL_ISSUES
          
          ## 📈 Environment Health Summary
          
          | Environment | Status | Issues | Actions Taken |
          |-------------|--------|---------|---------------|
          | Development | $([ -d reports/health-report-dev ] && echo "✅ CHECKED" || echo "⏭️ SKIPPED") | $DEV_ISSUES | $([ -d reports/cleanup-report-dev ] && echo "🧹 CLEANED" || echo "➖") |
          | Staging | $([ -d reports/health-report-staging ] && echo "✅ CHECKED" || echo "⏭️ SKIPPED") | $STAGING_ISSUES | $([ -d reports/cleanup-report-staging ] && echo "🧹 CLEANED" || echo "➖") |
          | Production | $([ -d reports/health-report-prod ] && echo "✅ CHECKED" || echo "⏭️ SKIPPED") | $PROD_ISSUES | 🔒 READ-ONLY |
          
          ## 🛡️ Security & Updates
          
          - **Security Audit**: $([ -d reports/security-audit-report ] && echo "✅ COMPLETED" || echo "⏭️ SKIPPED")
          - **Dependency Updates**: $([ -d reports/dependency-update-report ] && echo "✅ COMPLETED" || echo "⏭️ SKIPPED")
          
          ## 📋 Next Actions Required
          
          $(if [[ $TOTAL_ISSUES -gt 0 ]]; then
            echo "⚠️ **Attention Required**: $TOTAL_ISSUES issues found across environments"
            echo "- Review individual environment reports"
            echo "- Address critical issues in production"
            echo "- Schedule remediation for non-critical issues"
          else
            echo "✅ **All Systems Healthy**: No immediate action required"
            echo "- Continue regular monitoring"
            echo "- Review security recommendations"
          fi)
          
          ## 🔗 Detailed Reports
          
          $(find reports/ -name "*.md" | while read report; do
            echo "- [$(basename $report)]($(echo $report | sed 's/^reports\///'))"
          done)
          EOF

      - name: 🚨 Send notifications for critical issues
        if: contains(env.OVERALL_STATUS, 'NEEDS ATTENTION')
        run: |
          echo "🚨 Sending notification for issues found..."
          
          # Send to Teams webhook if configured
          if [[ -n "${{ env.ALERT_WEBHOOK }}" ]]; then
            curl -H "Content-Type: application/json" -d '{
              "summary": "Istio Templates Maintenance Alert",
              "title": "🚨 Maintenance Issues Detected",
              "text": "The maintenance workflow found '${TOTAL_ISSUES}' issues across environments. Please review the detailed reports.",
              "themeColor": "FF6B6B",
              "sections": [{
                "activityTitle": "Maintenance Report",
                "activitySubtitle": "$(date -u)",
                "facts": [
                  {"name": "Total Issues", "value": "${TOTAL_ISSUES}"},
                  {"name": "Environments Affected", "value": "$([ $DEV_ISSUES -gt 0 ] && echo "Dev "; [ $STAGING_ISSUES -gt 0 ] && echo "Staging "; [ $PROD_ISSUES -gt 0 ] && echo "Prod")"},
                  {"name": "Status", "value": "${OVERALL_STATUS}"}
                ]
              }],
              "potentialAction": [{
                "@type": "OpenUri",
                "name": "View Workflow Run",
                "targets": [{"os": "default", "uri": "https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"}]
              }]
            }' "${{ env.ALERT_WEBHOOK }}" || echo "Failed to send webhook notification"
          fi

      - name: 📊 Update workflow summary
        if: always()
        run: |
          cat maintenance-summary.md >> $GITHUB_STEP_SUMMARY

      - name: 📤 Upload consolidated report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: consolidated-maintenance-report
          path: |
            maintenance-summary.md
            reports/
          retention-days: 90

      - name: 🏷️ Create maintenance issue for tracking
        if: contains(env.OVERALL_STATUS, 'NEEDS ATTENTION')
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const summary = fs.readFileSync('maintenance-summary.md', 'utf8');
            
            github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `🔧 Maintenance Alert: ${process.env.TOTAL_ISSUES} issues found - ${new Date().toISOString().split('T')[0]}`,
              body: `${summary}
              
              ## 📋 Action Items
              
              - [ ] Review health reports for each environment
              - [ ] Address critical issues immediately
              - [ ] Schedule remediation for non-critical issues
              - [ ] Update monitoring dashboards if needed
              
              ---
              **Auto-generated by maintenance workflow** - Run ID: [\`${{ github.run_id }}\`](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})`,
              labels: ['maintenance', 'alert', 'ops-required']
            });